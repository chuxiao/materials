BRE: \    .    *    ^    $    [...]    \{n,m\}    \( \)    \n
ERE: \    .    *    ^    $    [...]    {n,m}    +    ?    |    ()

1. POSIX 字符集

    [:alnum:]      数字与字母字符
    [:alpha:]      字母字符
    [:blank:]      空格(space)与定位(tab)字符
    [:cntrl:]      控制字符
    [:digit:]      数字字符
    [:graph:]      非空格字符
    [:lower:]      小写字母字符
    [:print:]      可显示的字符
    [:punct:]      标点符号字符
    [:space:]      空白字符
    [:upper:]      大写字母字符
    [:xdigit:]     十六进制字符

2. 基本正则表达式(BRE)

    2.1 匹配单个字符

        一般字符指未正则表达式元字符,包括所有文字和数字字符,绝大多数的空白字符以及标点符号字符.一般字符在匹配时只匹配他们自己.

        正则表达式元字符不能匹配他们自己,需要转义.如\*匹配字面上的*,\\匹配字面上的\,\[匹配[.

        .(点号)匹配任一字符.如a.c匹配于abc,aac及aqc.

        方括号表达式用于匹配括号中的任一字符.如[aeiouy]表示所有的小写元音字母,c[aeiouy]t匹配于cat,cot以及cut,但不匹配于cbt.在方括号表达式里,^放在字首表示取反的意思,如[^aeiouy]表示小写元音字符以外的任何字符.

        方括号表达式的简写表示.[0-9]表示[0123456789],[0-9a-fA-F]表示[0123456789abcdefABCDEF].

        在方括号表达式里,所有的其他元字符都会失去其特殊意义.如[*\.]匹配于字面上的星号,反斜杠及句点.

        POSIX明确陈述,NUL字符是不需要匹配.

    2.2 后向引用

        后向引用指的是"匹配于正则表达式匹配到的先前部分".如

            \(ab\)\(cd\)[def]*\2\1 匹配于abcdcdab,abcdxxxxcdab,...
            \(why\).*\1表示一行里出现过两个why
            \([[:alpha:]_][[:alnum:]_]*\) = \1 表示简单的C/C++赋值语句

        后向引用在寻找重复字以及匹配引号时特别好用:
            \(["']\).*\1 匹配以单引号或双引号括起来的字,例如'foo',"bar"

    2.3 单个表达式匹配多字符

        * 表示匹配0个或多个前面的单个字符

        \{n\} 前置正则表达式所得结果重现n次

        \{n,\} 前置正则表达式所得结果重现至少n次

        \{n,m\} 前置正则表达式所得结果重现n至m次

    2.4 文本匹配锚点

        ^与$仅在BRE的起始与结尾处具有特殊意义.

    2.5 BRE运算符优先级,由高到低

        [..]    [==]    [::]         用于字符排序的方括号符号
        \metacharacter               转义的元字符
        []                           方括号表达式
        \(\)    \digit               子表达式与后向引用
        *    \{\}                    前置单个字符重现的正则表达式
        无符号                       连续
        ^ $                          锚点

3. 扩展正则表达式(ERE)

    3.1 匹配单个字符

        与BRE相同,但有一个例外.在awk里,\在方括号表达式里表示其他含义,因此,如果需要匹配左方括号,连字符,右方括号或是反斜杠,你应该使用[\[\-\]\\].

    3.2 后向引用不存在

        ERE里没有后向引用,\(,\)匹配的是字面上的左括号与右括号.

    3.3 匹配单个表达式与多个正则表达式

        * 在ERE中的用法与BRE一致

        在ERE中,{}不需要再像BRE中使用反斜杠(\{\})

        ? 匹配于0个或一个前置正则表达式

        + 匹配于1个或多个前置正则表达式

    3.4 交替

        | 表示匹配于这个序列或者另一个序列.如read|write匹配于read与write两者.

        | 运算符是ERE中优先级别最低的.

    3.5 分组

        在ERE中()用来表示一个分组.如((read|write)[[:space:]]*)+匹配多个连续出现的read或write,且中间可能有空格隔开.

    3.6 停驻文本匹配

        ^与$在ERE与BRE里的意义相同,都是用来匹配文本字符串或行的起始与结尾.不过有一点区别:有ERE中,^与$永远是元字符.所以,像ab^cd与ef$gh这样的正则表达式是有效的,只是匹配不到任何东西.

    3.7 ERE运算符优先级,从高到底

        [..]    [==]    [::]         用于字符排序的方括号符号
        \metacharacter               转义的元字符
        []                           方括号表达式
        ()                           分组
        *    +    ?    {}            前置单个字符重现的正则表达式
        无符号                       连续
        ^ $                          锚点
        |                            交替

4. 正则表达式的扩展

    \w        匹配任意字符,等同于[[:alnum:]_]
    \W        匹配任意非字符,等同于[^[:alnum:]_]
    \s        匹配任意空白字符
    \S        匹配任意非空白字符
    \<\>      匹配单词的起始与结尾

5. 程序与正则表达式

    BRE      grep     sed     vi    more
    ERE      egrep    awk     lex
    \<\>     grep     sed     vi    more

    注意:awk在其扩展正则表达式里可能不支持区间表达式,应该用其反斜杠形式(\{\}).
